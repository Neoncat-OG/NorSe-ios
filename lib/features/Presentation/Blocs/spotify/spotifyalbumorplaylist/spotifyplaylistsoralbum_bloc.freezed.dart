// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'spotifyplaylistsoralbum_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SpotifyplaylistsoralbumEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getalbumtracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getplaylisttracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getartisttoptrack,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_albumtracks value) getalbumtracks,
    required TResult Function(_playlisttracks value) getplaylisttracks,
    required TResult Function(_getartisttoptrack value) getartisttoptrack,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_albumtracks value)? getalbumtracks,
    TResult? Function(_playlisttracks value)? getplaylisttracks,
    TResult? Function(_getartisttoptrack value)? getartisttoptrack,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_albumtracks value)? getalbumtracks,
    TResult Function(_playlisttracks value)? getplaylisttracks,
    TResult Function(_getartisttoptrack value)? getartisttoptrack,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpotifyplaylistsoralbumEventCopyWith<$Res> {
  factory $SpotifyplaylistsoralbumEventCopyWith(
          SpotifyplaylistsoralbumEvent value,
          $Res Function(SpotifyplaylistsoralbumEvent) then) =
      _$SpotifyplaylistsoralbumEventCopyWithImpl<$Res,
          SpotifyplaylistsoralbumEvent>;
}

/// @nodoc
class _$SpotifyplaylistsoralbumEventCopyWithImpl<$Res,
        $Val extends SpotifyplaylistsoralbumEvent>
    implements $SpotifyplaylistsoralbumEventCopyWith<$Res> {
  _$SpotifyplaylistsoralbumEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getalbumtracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getplaylisttracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getartisttoptrack,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_albumtracks value) getalbumtracks,
    required TResult Function(_playlisttracks value) getplaylisttracks,
    required TResult Function(_getartisttoptrack value) getartisttoptrack,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_albumtracks value)? getalbumtracks,
    TResult? Function(_playlisttracks value)? getplaylisttracks,
    TResult? Function(_getartisttoptrack value)? getartisttoptrack,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_albumtracks value)? getalbumtracks,
    TResult Function(_playlisttracks value)? getplaylisttracks,
    TResult Function(_getartisttoptrack value)? getartisttoptrack,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements SpotifyplaylistsoralbumEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$albumtracksImplCopyWith<$Res> {
  factory _$$albumtracksImplCopyWith(
          _$albumtracksImpl value, $Res Function(_$albumtracksImpl) then) =
      __$$albumtracksImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SpotifyApi spotify, User user, String id});
}

/// @nodoc
class __$$albumtracksImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumEventCopyWithImpl<$Res, _$albumtracksImpl>
    implements _$$albumtracksImplCopyWith<$Res> {
  __$$albumtracksImplCopyWithImpl(
      _$albumtracksImpl _value, $Res Function(_$albumtracksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? spotify = null,
    Object? user = null,
    Object? id = null,
  }) {
    return _then(_$albumtracksImpl(
      null == spotify
          ? _value.spotify
          : spotify // ignore: cast_nullable_to_non_nullable
              as SpotifyApi,
      null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$albumtracksImpl implements _albumtracks {
  const _$albumtracksImpl(this.spotify, this.user, this.id);

  @override
  final SpotifyApi spotify;
  @override
  final User user;
  @override
  final String id;

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumEvent.getalbumtracks(spotify: $spotify, user: $user, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$albumtracksImpl &&
            (identical(other.spotify, spotify) || other.spotify == spotify) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, spotify, user, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$albumtracksImplCopyWith<_$albumtracksImpl> get copyWith =>
      __$$albumtracksImplCopyWithImpl<_$albumtracksImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getalbumtracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getplaylisttracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getartisttoptrack,
  }) {
    return getalbumtracks(spotify, user, id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
  }) {
    return getalbumtracks?.call(spotify, user, id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
    required TResult orElse(),
  }) {
    if (getalbumtracks != null) {
      return getalbumtracks(spotify, user, id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_albumtracks value) getalbumtracks,
    required TResult Function(_playlisttracks value) getplaylisttracks,
    required TResult Function(_getartisttoptrack value) getartisttoptrack,
  }) {
    return getalbumtracks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_albumtracks value)? getalbumtracks,
    TResult? Function(_playlisttracks value)? getplaylisttracks,
    TResult? Function(_getartisttoptrack value)? getartisttoptrack,
  }) {
    return getalbumtracks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_albumtracks value)? getalbumtracks,
    TResult Function(_playlisttracks value)? getplaylisttracks,
    TResult Function(_getartisttoptrack value)? getartisttoptrack,
    required TResult orElse(),
  }) {
    if (getalbumtracks != null) {
      return getalbumtracks(this);
    }
    return orElse();
  }
}

abstract class _albumtracks implements SpotifyplaylistsoralbumEvent {
  const factory _albumtracks(
          final SpotifyApi spotify, final User user, final String id) =
      _$albumtracksImpl;

  SpotifyApi get spotify;
  User get user;
  String get id;
  @JsonKey(ignore: true)
  _$$albumtracksImplCopyWith<_$albumtracksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$playlisttracksImplCopyWith<$Res> {
  factory _$$playlisttracksImplCopyWith(_$playlisttracksImpl value,
          $Res Function(_$playlisttracksImpl) then) =
      __$$playlisttracksImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SpotifyApi spotify, User user, String id});
}

/// @nodoc
class __$$playlisttracksImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumEventCopyWithImpl<$Res,
        _$playlisttracksImpl> implements _$$playlisttracksImplCopyWith<$Res> {
  __$$playlisttracksImplCopyWithImpl(
      _$playlisttracksImpl _value, $Res Function(_$playlisttracksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? spotify = null,
    Object? user = null,
    Object? id = null,
  }) {
    return _then(_$playlisttracksImpl(
      null == spotify
          ? _value.spotify
          : spotify // ignore: cast_nullable_to_non_nullable
              as SpotifyApi,
      null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$playlisttracksImpl implements _playlisttracks {
  const _$playlisttracksImpl(this.spotify, this.user, this.id);

  @override
  final SpotifyApi spotify;
  @override
  final User user;
  @override
  final String id;

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumEvent.getplaylisttracks(spotify: $spotify, user: $user, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$playlisttracksImpl &&
            (identical(other.spotify, spotify) || other.spotify == spotify) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, spotify, user, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$playlisttracksImplCopyWith<_$playlisttracksImpl> get copyWith =>
      __$$playlisttracksImplCopyWithImpl<_$playlisttracksImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getalbumtracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getplaylisttracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getartisttoptrack,
  }) {
    return getplaylisttracks(spotify, user, id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
  }) {
    return getplaylisttracks?.call(spotify, user, id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
    required TResult orElse(),
  }) {
    if (getplaylisttracks != null) {
      return getplaylisttracks(spotify, user, id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_albumtracks value) getalbumtracks,
    required TResult Function(_playlisttracks value) getplaylisttracks,
    required TResult Function(_getartisttoptrack value) getartisttoptrack,
  }) {
    return getplaylisttracks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_albumtracks value)? getalbumtracks,
    TResult? Function(_playlisttracks value)? getplaylisttracks,
    TResult? Function(_getartisttoptrack value)? getartisttoptrack,
  }) {
    return getplaylisttracks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_albumtracks value)? getalbumtracks,
    TResult Function(_playlisttracks value)? getplaylisttracks,
    TResult Function(_getartisttoptrack value)? getartisttoptrack,
    required TResult orElse(),
  }) {
    if (getplaylisttracks != null) {
      return getplaylisttracks(this);
    }
    return orElse();
  }
}

abstract class _playlisttracks implements SpotifyplaylistsoralbumEvent {
  const factory _playlisttracks(
          final SpotifyApi spotify, final User user, final String id) =
      _$playlisttracksImpl;

  SpotifyApi get spotify;
  User get user;
  String get id;
  @JsonKey(ignore: true)
  _$$playlisttracksImplCopyWith<_$playlisttracksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$getartisttoptrackImplCopyWith<$Res> {
  factory _$$getartisttoptrackImplCopyWith(_$getartisttoptrackImpl value,
          $Res Function(_$getartisttoptrackImpl) then) =
      __$$getartisttoptrackImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SpotifyApi spotify, User user, String id});
}

/// @nodoc
class __$$getartisttoptrackImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumEventCopyWithImpl<$Res,
        _$getartisttoptrackImpl>
    implements _$$getartisttoptrackImplCopyWith<$Res> {
  __$$getartisttoptrackImplCopyWithImpl(_$getartisttoptrackImpl _value,
      $Res Function(_$getartisttoptrackImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? spotify = null,
    Object? user = null,
    Object? id = null,
  }) {
    return _then(_$getartisttoptrackImpl(
      null == spotify
          ? _value.spotify
          : spotify // ignore: cast_nullable_to_non_nullable
              as SpotifyApi,
      null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$getartisttoptrackImpl implements _getartisttoptrack {
  const _$getartisttoptrackImpl(this.spotify, this.user, this.id);

  @override
  final SpotifyApi spotify;
  @override
  final User user;
  @override
  final String id;

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumEvent.getartisttoptrack(spotify: $spotify, user: $user, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$getartisttoptrackImpl &&
            (identical(other.spotify, spotify) || other.spotify == spotify) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, spotify, user, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$getartisttoptrackImplCopyWith<_$getartisttoptrackImpl> get copyWith =>
      __$$getartisttoptrackImplCopyWithImpl<_$getartisttoptrackImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getalbumtracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getplaylisttracks,
    required TResult Function(SpotifyApi spotify, User user, String id)
        getartisttoptrack,
  }) {
    return getartisttoptrack(spotify, user, id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult? Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
  }) {
    return getartisttoptrack?.call(spotify, user, id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(SpotifyApi spotify, User user, String id)? getalbumtracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getplaylisttracks,
    TResult Function(SpotifyApi spotify, User user, String id)?
        getartisttoptrack,
    required TResult orElse(),
  }) {
    if (getartisttoptrack != null) {
      return getartisttoptrack(spotify, user, id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_albumtracks value) getalbumtracks,
    required TResult Function(_playlisttracks value) getplaylisttracks,
    required TResult Function(_getartisttoptrack value) getartisttoptrack,
  }) {
    return getartisttoptrack(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_albumtracks value)? getalbumtracks,
    TResult? Function(_playlisttracks value)? getplaylisttracks,
    TResult? Function(_getartisttoptrack value)? getartisttoptrack,
  }) {
    return getartisttoptrack?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_albumtracks value)? getalbumtracks,
    TResult Function(_playlisttracks value)? getplaylisttracks,
    TResult Function(_getartisttoptrack value)? getartisttoptrack,
    required TResult orElse(),
  }) {
    if (getartisttoptrack != null) {
      return getartisttoptrack(this);
    }
    return orElse();
  }
}

abstract class _getartisttoptrack implements SpotifyplaylistsoralbumEvent {
  const factory _getartisttoptrack(
          final SpotifyApi spotify, final User user, final String id) =
      _$getartisttoptrackImpl;

  SpotifyApi get spotify;
  User get user;
  String get id;
  @JsonKey(ignore: true)
  _$$getartisttoptrackImplCopyWith<_$getartisttoptrackImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SpotifyplaylistsoralbumState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingtracks,
    required TResult Function(List<TrackSimple> tracks) tracks,
    required TResult Function(List<Track> tracks) playlisttracks,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingtracks,
    TResult? Function(List<TrackSimple> tracks)? tracks,
    TResult? Function(List<Track> tracks)? playlisttracks,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingtracks,
    TResult Function(List<TrackSimple> tracks)? tracks,
    TResult Function(List<Track> tracks)? playlisttracks,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingTracks value) loadingtracks,
    required TResult Function(_Tracks value) tracks,
    required TResult Function(_Playlisttracks value) playlisttracks,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingTracks value)? loadingtracks,
    TResult? Function(_Tracks value)? tracks,
    TResult? Function(_Playlisttracks value)? playlisttracks,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingTracks value)? loadingtracks,
    TResult Function(_Tracks value)? tracks,
    TResult Function(_Playlisttracks value)? playlisttracks,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpotifyplaylistsoralbumStateCopyWith<$Res> {
  factory $SpotifyplaylistsoralbumStateCopyWith(
          SpotifyplaylistsoralbumState value,
          $Res Function(SpotifyplaylistsoralbumState) then) =
      _$SpotifyplaylistsoralbumStateCopyWithImpl<$Res,
          SpotifyplaylistsoralbumState>;
}

/// @nodoc
class _$SpotifyplaylistsoralbumStateCopyWithImpl<$Res,
        $Val extends SpotifyplaylistsoralbumState>
    implements $SpotifyplaylistsoralbumStateCopyWith<$Res> {
  _$SpotifyplaylistsoralbumStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingtracks,
    required TResult Function(List<TrackSimple> tracks) tracks,
    required TResult Function(List<Track> tracks) playlisttracks,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingtracks,
    TResult? Function(List<TrackSimple> tracks)? tracks,
    TResult? Function(List<Track> tracks)? playlisttracks,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingtracks,
    TResult Function(List<TrackSimple> tracks)? tracks,
    TResult Function(List<Track> tracks)? playlisttracks,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingTracks value) loadingtracks,
    required TResult Function(_Tracks value) tracks,
    required TResult Function(_Playlisttracks value) playlisttracks,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingTracks value)? loadingtracks,
    TResult? Function(_Tracks value)? tracks,
    TResult? Function(_Playlisttracks value)? playlisttracks,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingTracks value)? loadingtracks,
    TResult Function(_Tracks value)? tracks,
    TResult Function(_Playlisttracks value)? playlisttracks,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SpotifyplaylistsoralbumState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingTracksImplCopyWith<$Res> {
  factory _$$LoadingTracksImplCopyWith(
          _$LoadingTracksImpl value, $Res Function(_$LoadingTracksImpl) then) =
      __$$LoadingTracksImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingTracksImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumStateCopyWithImpl<$Res,
        _$LoadingTracksImpl> implements _$$LoadingTracksImplCopyWith<$Res> {
  __$$LoadingTracksImplCopyWithImpl(
      _$LoadingTracksImpl _value, $Res Function(_$LoadingTracksImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingTracksImpl implements _LoadingTracks {
  const _$LoadingTracksImpl();

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumState.loadingtracks()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingTracksImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingtracks,
    required TResult Function(List<TrackSimple> tracks) tracks,
    required TResult Function(List<Track> tracks) playlisttracks,
  }) {
    return loadingtracks();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingtracks,
    TResult? Function(List<TrackSimple> tracks)? tracks,
    TResult? Function(List<Track> tracks)? playlisttracks,
  }) {
    return loadingtracks?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingtracks,
    TResult Function(List<TrackSimple> tracks)? tracks,
    TResult Function(List<Track> tracks)? playlisttracks,
    required TResult orElse(),
  }) {
    if (loadingtracks != null) {
      return loadingtracks();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingTracks value) loadingtracks,
    required TResult Function(_Tracks value) tracks,
    required TResult Function(_Playlisttracks value) playlisttracks,
  }) {
    return loadingtracks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingTracks value)? loadingtracks,
    TResult? Function(_Tracks value)? tracks,
    TResult? Function(_Playlisttracks value)? playlisttracks,
  }) {
    return loadingtracks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingTracks value)? loadingtracks,
    TResult Function(_Tracks value)? tracks,
    TResult Function(_Playlisttracks value)? playlisttracks,
    required TResult orElse(),
  }) {
    if (loadingtracks != null) {
      return loadingtracks(this);
    }
    return orElse();
  }
}

abstract class _LoadingTracks implements SpotifyplaylistsoralbumState {
  const factory _LoadingTracks() = _$LoadingTracksImpl;
}

/// @nodoc
abstract class _$$TracksImplCopyWith<$Res> {
  factory _$$TracksImplCopyWith(
          _$TracksImpl value, $Res Function(_$TracksImpl) then) =
      __$$TracksImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<TrackSimple> tracks});
}

/// @nodoc
class __$$TracksImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumStateCopyWithImpl<$Res, _$TracksImpl>
    implements _$$TracksImplCopyWith<$Res> {
  __$$TracksImplCopyWithImpl(
      _$TracksImpl _value, $Res Function(_$TracksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tracks = null,
  }) {
    return _then(_$TracksImpl(
      null == tracks
          ? _value._tracks
          : tracks // ignore: cast_nullable_to_non_nullable
              as List<TrackSimple>,
    ));
  }
}

/// @nodoc

class _$TracksImpl implements _Tracks {
  const _$TracksImpl(final List<TrackSimple> tracks) : _tracks = tracks;

  final List<TrackSimple> _tracks;
  @override
  List<TrackSimple> get tracks {
    if (_tracks is EqualUnmodifiableListView) return _tracks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tracks);
  }

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumState.tracks(tracks: $tracks)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TracksImpl &&
            const DeepCollectionEquality().equals(other._tracks, _tracks));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_tracks));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TracksImplCopyWith<_$TracksImpl> get copyWith =>
      __$$TracksImplCopyWithImpl<_$TracksImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingtracks,
    required TResult Function(List<TrackSimple> tracks) tracks,
    required TResult Function(List<Track> tracks) playlisttracks,
  }) {
    return tracks(this.tracks);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingtracks,
    TResult? Function(List<TrackSimple> tracks)? tracks,
    TResult? Function(List<Track> tracks)? playlisttracks,
  }) {
    return tracks?.call(this.tracks);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingtracks,
    TResult Function(List<TrackSimple> tracks)? tracks,
    TResult Function(List<Track> tracks)? playlisttracks,
    required TResult orElse(),
  }) {
    if (tracks != null) {
      return tracks(this.tracks);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingTracks value) loadingtracks,
    required TResult Function(_Tracks value) tracks,
    required TResult Function(_Playlisttracks value) playlisttracks,
  }) {
    return tracks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingTracks value)? loadingtracks,
    TResult? Function(_Tracks value)? tracks,
    TResult? Function(_Playlisttracks value)? playlisttracks,
  }) {
    return tracks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingTracks value)? loadingtracks,
    TResult Function(_Tracks value)? tracks,
    TResult Function(_Playlisttracks value)? playlisttracks,
    required TResult orElse(),
  }) {
    if (tracks != null) {
      return tracks(this);
    }
    return orElse();
  }
}

abstract class _Tracks implements SpotifyplaylistsoralbumState {
  const factory _Tracks(final List<TrackSimple> tracks) = _$TracksImpl;

  List<TrackSimple> get tracks;
  @JsonKey(ignore: true)
  _$$TracksImplCopyWith<_$TracksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlaylisttracksImplCopyWith<$Res> {
  factory _$$PlaylisttracksImplCopyWith(_$PlaylisttracksImpl value,
          $Res Function(_$PlaylisttracksImpl) then) =
      __$$PlaylisttracksImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Track> tracks});
}

/// @nodoc
class __$$PlaylisttracksImplCopyWithImpl<$Res>
    extends _$SpotifyplaylistsoralbumStateCopyWithImpl<$Res,
        _$PlaylisttracksImpl> implements _$$PlaylisttracksImplCopyWith<$Res> {
  __$$PlaylisttracksImplCopyWithImpl(
      _$PlaylisttracksImpl _value, $Res Function(_$PlaylisttracksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tracks = null,
  }) {
    return _then(_$PlaylisttracksImpl(
      null == tracks
          ? _value._tracks
          : tracks // ignore: cast_nullable_to_non_nullable
              as List<Track>,
    ));
  }
}

/// @nodoc

class _$PlaylisttracksImpl implements _Playlisttracks {
  const _$PlaylisttracksImpl(final List<Track> tracks) : _tracks = tracks;

  final List<Track> _tracks;
  @override
  List<Track> get tracks {
    if (_tracks is EqualUnmodifiableListView) return _tracks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tracks);
  }

  @override
  String toString() {
    return 'SpotifyplaylistsoralbumState.playlisttracks(tracks: $tracks)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlaylisttracksImpl &&
            const DeepCollectionEquality().equals(other._tracks, _tracks));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_tracks));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PlaylisttracksImplCopyWith<_$PlaylisttracksImpl> get copyWith =>
      __$$PlaylisttracksImplCopyWithImpl<_$PlaylisttracksImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingtracks,
    required TResult Function(List<TrackSimple> tracks) tracks,
    required TResult Function(List<Track> tracks) playlisttracks,
  }) {
    return playlisttracks(this.tracks);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingtracks,
    TResult? Function(List<TrackSimple> tracks)? tracks,
    TResult? Function(List<Track> tracks)? playlisttracks,
  }) {
    return playlisttracks?.call(this.tracks);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingtracks,
    TResult Function(List<TrackSimple> tracks)? tracks,
    TResult Function(List<Track> tracks)? playlisttracks,
    required TResult orElse(),
  }) {
    if (playlisttracks != null) {
      return playlisttracks(this.tracks);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadingTracks value) loadingtracks,
    required TResult Function(_Tracks value) tracks,
    required TResult Function(_Playlisttracks value) playlisttracks,
  }) {
    return playlisttracks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadingTracks value)? loadingtracks,
    TResult? Function(_Tracks value)? tracks,
    TResult? Function(_Playlisttracks value)? playlisttracks,
  }) {
    return playlisttracks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadingTracks value)? loadingtracks,
    TResult Function(_Tracks value)? tracks,
    TResult Function(_Playlisttracks value)? playlisttracks,
    required TResult orElse(),
  }) {
    if (playlisttracks != null) {
      return playlisttracks(this);
    }
    return orElse();
  }
}

abstract class _Playlisttracks implements SpotifyplaylistsoralbumState {
  const factory _Playlisttracks(final List<Track> tracks) =
      _$PlaylisttracksImpl;

  List<Track> get tracks;
  @JsonKey(ignore: true)
  _$$PlaylisttracksImplCopyWith<_$PlaylisttracksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
